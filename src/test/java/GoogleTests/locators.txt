Xpath:
Символ / аналогичен символу > в CSS-селекторе, а символ // - пробелу. Их смысл:
el1/el2 - выбирает элементы el2, являющиеся прямыми потомками el1;
el1//el2 - выбирает элементы el2, являющиеся потомками el1 любой степени вложенности
//. Это будет означать, что мы хотим найти всех потомков корневого элемента без указания корневого элемента.
 Например, запрос //div вернет вам все элементы с тегом <div>
Символ [ ] - это команда фильтрации-Если по запросу найдено несколько элементов, то будет произведена фильтрация
 по правилу, указанному в скобках. по любому атрибуту, будь то id, class, title (или любой другой).
 найти картинку, для этого можно выполнить запрос //img[@id='bullet']
 //div[@class='g'] - найти атрибут со значением “g”
 по порядковому номеру.  мы хотим выбрать вторую по порядку карточку с котом. Для этого найдем элемент с классом "row"
  и возьмем его второго потомка: //div[@class="row"]/div[2]
по полному совпадению текста. Да, XPath - это единственный способ найти элемент по внутреннему тексту.

 Если мы хотим найти блок текста с котом-Лениным, можно воспользоваться XPath селектором //p[text()="Lenin cat"].
  Такой селектор вернет элемент, только если текст полностью совпадет. Здесь важно сказать,
  что не всегда поиск по тексту - это хорошая практика, особенно в случае мультиязычных сайтов.
  //*[text()='Нужный мне текст']  - найти по тексту
по частичному совпадению текста или атрибута. Для этого нужна функция contains.
 Запрос //p[contains(text(), "cat")] вернет нам все абзацы текста, которые содержат слово cat.
  Точно так же можно искать по частичному совпадению других атрибутов, это удобно, если у элемента несколько классов.
   Посмотрите на код навбара сайта с котами. Его можно найти селектором //div[contains(@class, "navbar")] .
в фильтрации еще можно использовать булевы операции (and, or, not) и некоторые простые арифметические выражения
 (но вообще не стоит, наверное).
  Допустим, мы хотим найти картинку обязательно с data-type "animal" и именем "bullet", для этого подойдет запрос:
   //img[@name='bullet-cat' and @data-type='animal']
Символ * - команда выбора всех элементов
Например можем найти текст в заголовке запросом //div/*[@class="jumbotron-heading"].
Это может быть удобно, когда мы не знаем точно тег элемента, который ищем.
//*[contains(@class, 'Нужная мне часть  атрибута')]

//*[@id=sdggg’] - find id=sdggg
//*[@name='q'] - все элементы с атрибутом name='q'
//p[@name='q'] - все теги Р с атрибутом name='q'
//ul -все элементы UL т.е списки ( весь блок)
//ul//li[2] - все элементы LI т.е строку списка
//a  -все элементы A т.е ссылки
//*[@href=”www.qooqle.com”] - все элементы href=”www.qooqle.com”
//a[@href=”www.qooqle.com”] - все элементы “A” с атрибутом href=”www.qooqle.com”

//input[@name='test1']    -найти группу радиобатонов
//input[@type=”check box” and @value='2'] - найти чекбокс
//input[@id=”login”]    -найти поле input
//input[@class='gLFyf gsfi']  - окно поиска
//*[@class='gLFyf gsfi'] - тоже самое
//input[@type='text']
//input[@name='q' and @class='gLFyf gsfi']
- тоже самое center:nth-child(1) > input[value="Пошук Google" ] - кнопка ПОИСК
//textarea[@name=’textArea’]   -найти поле ввода текста TextArea
//button[@type=’submit’]  -  найти кнопку ввод
//form -найти форму

“..” -  вернуться на уровень ниже
“.” - поиск продолжать в этом элементе(пример с таблицей)
//table[1]/.//tr[2]//td[1]
-https://youtu.be/kFE3ziqGVBcС  since 20 minu